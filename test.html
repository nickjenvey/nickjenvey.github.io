<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hover Glitch Effect</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/dynamics.js@1.0.0/dynamics.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.min.js"></script>
  <style>
    body {
      font-family: 'Open Sans', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #101214;
      color: white;
      text-align: center;
    }

    #logo-container {
      position: relative;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      visibility: visible;
    }

    #header-logo {
      width: 120px;
      height: 120px;
    }

    .content {
      margin-top: 30px;
    }

    a {
      color: white;
      font-size: 20px;
      text-decoration: none;
      position: relative;
    }

    a:hover {
      color: #ff00ff;
    }

  </style>
</head>
<body>

  <div id="logo-container">
    <svg id="header-logo" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
      <circle cx="60" cy="60" r="50" stroke="black" stroke-width="10" fill="none"/>
    </svg>
  </div>

  <div class="content">
    <h2>Hover over the SVG or links below</h2>
    <a href="#" class="glitch-link">Link 1</a>
    <a href="#" class="glitch-link">Link 2</a>
    <a href="#" class="glitch-link">Link 3</a>
  </div>

  <script>
    // Create Glitch Effect on Links
    function animateLink(el) {
      let animating = true;
      let box = el.getBoundingClientRect();

      let animate = function() {
        let masks = createMasksWithStripes(3, box, 3);
        let clonedEls = [];

        for (let i = 0; i < masks.length; i++) {
          let clonedEl = cloneAndStripeElement(el, masks[i], document.body);
          let childrenEls = Array.prototype.slice.apply(clonedEl.querySelectorAll('path'));
          childrenEls.push(clonedEl);
          for (let k = 0; k < childrenEls.length; k++) {
            let color = tinycolor(`hsl(${Math.round(Math.random() * 360)}, 80%, 65%)`);
            let rgb = color.toRgbString();
            dynamics.css(childrenEls[k], {
              color: rgb,
              fill: rgb,
            });
          }
          clonedEl.style.display = '';
          clonedEls.push(clonedEl);
        }

        for (let i = 0; i < clonedEls.length; i++) {
          let clonedEl = clonedEls[i];
          dynamics.css(clonedEl, {
            translateX: Math.random() * 10 - 5,
          });

          dynamics.setTimeout(function() {
            dynamics.css(clonedEl, {
              translateX: 0,
            });
          }, 50);

          dynamics.setTimeout(function() {
            dynamics.css(clonedEl, {
              translateX: Math.random() * 5 - 2.5,
            });
          }, 100);

          dynamics.setTimeout(function() {
            document.body.removeChild(clonedEl);
          }, 150);
        }

        dynamics.setTimeout(function() {
          if(animating) {
            animate();
          }
          for (let i = 0; i < masks.length; i++) {
            let maskEl = document.querySelector(`#${masks[i]}`);
            maskEl.parentNode.removeChild(maskEl);
          }
        }, Math.random() * 1000);
      };

      animate();

      return {
        stop: function() {
          animating = false;
        },
      };
    };

    function handleMouseOver(e) {
      let el = e.target;
      while (el && el.tagName.toLowerCase() !== 'a') {
        el = el.parentNode;
      }
      if (!el) {
        return;
      }
      let r = animateLink(el);

      let handleMouseOut = function(e) {
        el.removeEventListener('mouseout', handleMouseOut);
        r.stop();
      }

      el.addEventListener('mouseout', handleMouseOut);
    }

    function createMasksWithStripes(count, box, averageHeight = 10) {
      let masks = [];
      for (let i = 0; i < count; i++) {
        masks.push([]);
      }
      let maskNames = [];
      for (let i = 0; i < masks.length; i++) {
        maskNames.push(`clipPath${i}`);
      }

      let maskIdx = 0;
      let x = 0;
      let y = 0;
      let stripeHeight = averageHeight;
      while (true) {
        let w = Math.max(stripeHeight * 10, Math.round(Math.random() * box.width));
        masks[maskIdx].push(`
          M ${x},${y} L ${x + w},${y} L ${x + w},${y + stripeHeight} L ${x},${y + stripeHeight} Z
        `);

        maskIdx += 1;
        if (maskIdx >= masks.length) {
          maskIdx = 0;
        }

        x += w;
        if (x > box.width) {
          x = 0;
          y += stripeHeight;
          stripeHeight = Math.round(Math.random() * averageHeight + averageHeight / 2);
        }
        if (y >= box.height) {
          break;
        }
      }

      masks.forEach(function (rects, i) {
        let el = createSvgChildEl(`<clipPath id="${maskNames[i]}">
          <path d="${rects.join(' ')}" fill="white"></path>
        </clipPath>`);
        document.querySelector('#clip-paths g').appendChild(el);
      });

      return maskNames;
    }

    function cloneAndStripeElement(element, clipPathName, parent) {
      let el = element.cloneNode(true);
      let box = element.getBoundingClientRect();
      let parentBox = parent.getBoundingClientRect();
      box = {
        top: box.top - parentBox.top,
        left: box.left - parentBox.left,
        width: box.width,
        height: box.height,
      };
      let style = window.getComputedStyle(element);

      dynamics.css(el, {
        position: 'absolute',
        left: Math.round(box.left + window.scrollX),
        top: Math.round(box.top + window.scrollY),
        width: Math.ceil(box.width),
        height: Math.ceil(box.height),
        display: 'none',
        pointerEvents: 'none',
        background: '#101214',
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        color: style.color,
        textDecoration: style.textDecoration,
      });
      parent.appendChild(el);
      el.style['-webkit-clip-path'] = `url(/#${clipPathName})`;
      el.style['clip-path'] = `url(/#${clipPathName})`;

      return el;
    }

    // Attach the hover effect to all links
    const linkEls = document.querySelectorAll('.glitch-link');
    for (let i = 0; i < linkEls.length; i++) {
      linkEls[i].addEventListener('mouseover', handleMouseOver);
    }

    // Create Glitch Effect on Logo
    function animateLogo() {
      let el = document.querySelector('#header-logo');
      let box = el.getBoundingClientRect();
      let count = 10 + Math.random() * 10;
      let masks = createMasksWithStripes(count, box, Math.round(100 / count));
      let clonedEls = [];

      for (let i = 0; i < masks.length; i++) {
        let clonedEl = cloneAndStripeElement(el, masks[i], document.body);
        let path = clonedEl.querySelector('path');
        let color = tinycolor(`hsl(${Math.round(Math.random() * 360)}, 80%, 65%)`);
        dynamics.css(path, {
          fill: color.toRgbString(),
        });
        clonedEls.push(clonedEl);
      }

      for (let i = 0; i < clonedEls.length; i++) {
        let clonedEl = clonedEls[i];
        let d = Math.random() * 100;

        dynamics.setTimeout(function() {
          clonedEl.style.display = '';
          dynamics.css(clonedEl, {
            translateX: Math.random() * 100 - 50,
          });
        }, d);

        dynamics.setTimeout(function() {
          dynamics.css(clonedEl, {
            translateX: Math.random() * 20 - 10,
          });
        }, d + 50);

        dynamics.setTimeout(function() {
          dynamics.css(clonedEl, {
            translateX: Math.random() * 5 - 2.5,
          });
        }, d + 100);

        dynamics.setTimeout(function() {
          document.body.removeChild(clonedEl);
        }, d + 150);
      }
    };

    // Trigger the logo animation on hover
    const logo = document.querySelector('#header-logo');
    logo.addEventListener('mouseover', animateLogo);
  </script>

</body>
</html>
